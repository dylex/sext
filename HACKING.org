* sext, lists with statically encoded length

** Goals
   We need a set of combinators to build strings/lists which support
   static length-checking.

   Sext is a list-like datatype with length encoded in its type. We'd
   also like to support several of concrete representations for
   strings like Text or ByteString so that an appropriate type may be
   used when a problem demands it.

   We also want to support native GHC type-level natural numbers
   (provided by GHC.TypeLits) to encode length instead of any other
   type-level number representation: now that a basic solver is
   available for type-level naturals in GHC 7.8, the notation provided
   by them is particularly expressive and the implementation does not
   rely on any TH hacks.

   The library must introduce as little run-time overhead as possible.
   Thus we aim to implement a thin type-level wrapper over operations
   already provided by representation types. Operations like take or
   drop still require run-time access to type information (in form of
   Nat singletons representing container size).

** Sextable class
   Sextable class maps operations for concrete types over constructor.
   Combinators are polymorphic and support any instance of Sextable
   class:

   - lists
   - Text
   - ByteString

   Type safety is provided by means of an associated type Sext.
   Sextable methods map basic type operations over this wrapper.

** Lists/strings
   Strings are lists, so we also provide instances for [a] type.
   mkSext TH macro provides a single unique name which can be supplied
   to container/element type generators. This can be used to generate
   instances for list and other Functor unary types.

** String literals
   We want to be able to include sext values in our programs in the
   form of string literals, similar to what's possible for Text or
   ByteString using OverloadedStrings extension. However, IsString
   type class is not an option: we ne need to capture lengths of
   string literals in compile time while not exposing an unsafe
   operation in IsString instance. The only method of IsString class,
   fromString, disregards string length information and requires being
   exposed in order for OverloadedStrings to be supported for sext
   users.

   Template Haskell seems to be an answer: we could easily implement a
   sext splice, used as follows:

   : $(sext "Foobar")

   it would expand to this:

   : Sext "Foobar" :: Sext 6 a
