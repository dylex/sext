* sext: lists, Texts, ByteStrings with statically encoded length
** Goals
   We need a set of combinators to build strings/lists which support
   static length-checking.

   Sext is a list-like datatype with length encoded in its type. We'd
   also like to support several of concrete representations for
   strings like Text or ByteString so that an appropriate type may be
   used when a problem demands it.

   We also want to support native GHC type-level natural numbers
   (provided by GHC.TypeLits) to encode length instead of any other
   type-level number representation: now that a basic solver is
   available for type-level naturals in GHC 7.8, the notation provided
   by them is particularly expressive and the implementation does not
   rely on any TH hacks.

   The library must introduce as little run-time overhead as possible.
   Thus we aim to implement a thin type-level wrapper over operations
   already provided by representation types. Operations like take or
   drop still require run-time access to type information (in form of
   Nat singletons representing container size).

** Sextable class
   Sextable class maps operations for concrete types over constructor.
   Combinators are polymorphic and support any instance of Sextable
   class:

   - lists
   - Text
   - ByteString

   Type safety is provided by means of an associated type Sext.
   Sextable methods map basic type operations over this wrapper.

** Generating instances for Sextable
   Strings are lists, so we also provide instances for [a] type.

   mkSextable TH macro provides a single unique name which can be
   supplied to container/element type generators. This can be used to
   generate instances for list and other Functor unary types.

   Methods definitions are built without any quoting: associated type
   constructor name would need to be spliced (which is impossible).

** String literals
   We want to be able to include sext values in our programs in the
   form of string literals, similar to what's possible for Text or
   ByteString using OverloadedStrings extension. However, IsString
   type class is not an option: we ne need to capture and check
   lengths of string literals in compile time while not exposing an
   unsafe operation in IsString instance. The only method of IsString
   class, fromString, disregards string length information and
   requires being exposed in order for OverloadedStrings to be
   supported for sext users. Making fromString non-total would
   postpone the actual check to runtime which is not desirable as
   well.

   Template Haskell seems to be an answer: we could easily implement a
   sext splice, used as follows:

   : $(sext "Foobar")

   it would expand to this:

   : Sext "Foobar" :: Sext 6 a

   where a is a type variable restricted to instances of both Sextable
   and IsString. Actual literal length is encoded in the type of the
   produced expression. We use untyped Template Haskell since types
   cannot be spliced.

   We also provide create, create' and unsafeCreate methods in
   Sextable class to enable interfacing Sext with run-time IO sources.
   They do not provide as much compile-time safety as the sext macro
   does.

** Type ambiguity

   An expression like

   : (take $ padLeft ' ' sext) :: Sext n t

   won't typecheck. Both combinators have no knowledge about the exact
   amount characters which need to be dropped/added to sext.
